- Page Object Model (POM)
- Sẽ đảm bảo việc là tách biệt trách nhiệm
- phân chia thành 2 thành phần chính
1. kịch bản test (test script): đại diện cho business logic
2. đối tượng trang  (page object) : đại diện cho technical implenmentation -> tương tác với UI như thế nào
-> chia thành các class -> mỗi 1 class đại diện cho 1 trang

--> giải quyết được thách thức lớn nhất trong auto
1. tính dễ bảo trì
- nó sẽ tập trung tất cả các selector và phương thức của trang custom bao gồm ví dụ là: company locator
2. Tính tái sử dụng
- tạo ra các phuơng thức (actions) đại diện cho hành vi nghiệp vụ (business behavior)
-> ví dụ có loginPage.login ('user','password')
3. Tính dễ đọc

Để giải quyết vấn đề DRY (don't repeat yourself) => (trang cơ sở )
basepage => là 1 lớp cha trừu tượng mà tất cả các page object khác (loginpage), sẽ kế thừa
=> đóng vai trò như 1 hd giao diện chung. định nghĩa tập hợp các yếu tố và hành động mà mọi trang trong ứng dụng đều phải có quyền truy cập

VD: hệ thống nv và công cụ chung
-> mọi nv đều cần sử dụng chung 1 số công cụ của cty, VD như email service


ngày 16/12/2025

cấu trúc chuẩn của 2 môi trường (dev và stagging)
.env (1.cấu hình chung- ai cũng giống ai)
.env.development (2. cấu hình riêng cho DEV)
.env.development.local (3.bí mật- chỉ có máy bạn có-k up lên git)
.env.staging (4.cấu hình cho môi trường stagging)

..vị trí ở root (thư mục gốc)ngang hàng vs package.json


thứ tự ưu tiên là
//biến phụ thuộc là NODE_ENV=abc
.env.[NODE_EVN].local hoặc .env [NODE_ENV]


1. .env (độ ưu tiên thấp nhất)
2. .env.development (tb)
3. .env.development.local (cao nhất ở môi trường dev)
4. .env.staging (cao nhất ở môi trường stagging)

//nguyên tắc -> cái load sẽ ghi đè lên load trước
trên phiếu NODE_ENV ghe development -> thủ thư sẽ tìm tới tất cả môi trường có tên .env.development

trường hợp mà NODE_ENV ghi staging -> thủ thư tìm cả môi trường có tên .env.staging

để lấy thông tin biến nt ta dùng process.env.key mà ta mong muốn
process.env.BASE_URL ->https://dev.crm.anhtester.com

///
dotenv flow hay dotenv hoạt động dựa trên process.cwd () (current working directory - thư mục hiện tại đang gõ lệnh)

trên windows ->terminal là powershell
trên gitbash, mac, linux ->mặc định

WINDOW
$env:NODE_ENV="staging";  npx playwright test ./tests/env-demo.spec.ts

mac
NODE_ENV=staging npx playwright test ./tests/env-demo.spec.ts

as (alias)
//"test:dev": "cross-env NODE_ENV=development npx playwright test",

    "test:uat": "cross-env NODE_ENV=staging npx playwright test"

    -> cross-env NODE_ENV=development npx playwright test ./tests/env-demo.spec.ts

npm run test:dev ./tests/env-demo.spec.ts



HOOKS (life cycle)

tứ trụ hooks (life cycle)

beforeAll (worker) --> 1 lần duy nhất /file

beforeEach (test) chạy lặp lại mỗi lần trước MỖI lần test

afterEach (test) chạy lặp lại mỗi lần sau Mỗi lần test

afterAll (worker) -> 1 lần duy nhất sau khi chạy hết test


WORKER REUSE

4 worker - 100 bài test

1. worker 1 chạy before all (mở page)
2. worker 1 chạy Test A (login -> chuyển sang dashboard)
3. worker 1 chưa tắt-> nó nhận tiếp test B
4. lúc này before all không chạy lại (vì nó là beforeall -> chạy 1 lần cho cả file worker đó)
5. test B nhận lại các sharedpage cũ từ A (đang ở dashboard)
6. -> fail


FIXTURE

giống beforeEach -> nó tự động taoj page mới cho mỗi bài test (sạch sẽ)
không cần let hay biến global. Page được truyền thẳng vào hàm test {page}
tự động dọn dẹp depk * (khi chạy xong fixture tự đóng page), tự giải phóng RAM
tái sử dụng .viết 1 lần sử dụng cho 1000 test


ngày 20/12/2025
playwright sẽ thực hiện 2 bước

b1: khoanh vùng (scoping) => dựng hàng rào nơi folder test cta sẽ thực hiện thông qua testDir
b2: lập ds ứng viên () -> quét hết để lấy file testMatch
so với vd checkout.txt -> đã bị loại bỏ vì k hợp lệ
=> kqua là PW tạo được 1 ds mới bao gồm nhưngx file hợp lệ

khi đó cta gõ
npx playwright test checkout => so với tests/checkout.spec.ts -> khớp (có chứa checkout)
//tests/logintest.spec.ts  -> không khớp -> không chạy

cú pháp glob (kp regex)
** -> recursive wildcrad -> bất kì thư mục nào bao nhiêu cũng được
* -> bất kì tên gì
.spec.ts -> extension đuôi file cố định

projects:
Mục đích 1: tối ưu hoá tài nguyên
..vấn đề 100 TCs API và 100 TCs UI
Mục đích 2: ma trận kiểm thử (test matrix) : 
Mục đích 3: điều phối chạy *orchestration
có thể cấu hình setup trạng thái đăng nhập -> chạy test -> tear down
thiết lập sự phụ thuộc vào các file test

Đặc tính project -> kế thừa ghi đè
Ưu tiên 1: cấu hình trong từng file test
Ưu tiên 2: cấu hình trong từng project
Ưu tiên 3: cấu hình trong global

cái riêng PROJECT CONFIG SẼ GHI ĐÈ CÁI CHUNG TOP LEVEL CONFIG ->
global config

thêm đuôi 

1. Job A. spec.ts chạy trên project API (api.spec1.ts)

2. Job B chạy trên desktop (cart.spec1.ts)

3. Job C chạy trên desktop (login.spec1.ts)

4. Job D chạy trên mobile (cart.spec1.ts)

5. Job E. chạy trên mobile (login.spec1.ts)







projects: [

    //proejct chuyên chạy API

    {

      name: 'api-engine',

      testMatch: '**/api/*.spec.ts',

      use: {

        browserName: undefined,

        //ko ghi đè gì cả -> kế thừa toàn bộ của global use

      },

    },

    //project desktop chay UI

    {

      name: 'desktop-chrome',

      testMatch: '**/ui/*.spec.ts',

      use: {

        ...devices['Desktop Chrome'],

        headless: true,

      },

    },

    //project chuyeen chay ui iphone

    {

      name: 'mobile-ios',

      testMatch: '**/ui/*.spec.ts',

      use: {

        ...devices['iPhone 12 Pro Max'],

        headless: true,

      },

    },

  ],




import { FullConfig } from '@playwright/test';

async function globalSetup(config: FullConfig) {

  console.log(`[GLOBAL SETUP] bawts đầu khởi động hệ thống`);

  await new Promise((r) => setTimeout(r, 1000));

  process.env.DB_CONNECTION_URL = 'postgres://admin:123';

  process.env.API_ENDPOINT = '8080';

}

export default globalSetup;


//3/1/2026
API= Application Programming Interface
Application: là giống các phần mềm facebook, zalo
programming: là cách ta viết được code
Interface -> là nơi gặp gỡ , cầu nối để 2 thằng xa lạ nói chuyện với nhau 

FE: (BẠN) ngồi ở bàn ăn... muốn ăn bánh mì pate
BE:(bếp) là nơi chứa thịt bò, gia vị, đầu bếp
API (bồi bàn) gắn kết FE VÀ BE

Bồi bàn (API) sẽ làm các việc
+B1: (Request) đưa ra thực đơn cho bồi bàn 
+B2: Process: bồi bàn mang tờ giấy đó cho đầu bêps
+B3: REPONSE: bếp nấu xong, bồi bàn đưa đĩa chứa bánh mì cho bạn 

Hiện nay có nhưngx công nghệ để API trổ tài
1. Restful API:
VD: mình đang đứng ở 1 máy bán nước tự động (BE)
- Trên máy có nút A(COCA), B(PEPSI) => đây chính là API_ENDPOINT
-> ví dụ muốn coca -> ấn nút A -> máy nhả 1 lon coca
=> vấn đề vs chuẩn restful API
= Thừa mức : nhả ra lon 330ml => uống 1 ngum ném đi => phí phạm(tốn băng thông)
- mất công : coca+bimbim => nhấn 2 lần, 1 lần là A , 1 lần là C (bimbim) => thao tác 2 lần gửi Request

2. Do phở bò (fb) phát triển -> (GraphQL)
Bối cảnh: mình vào 1 quán bar xịn xò, gặp a bartender (BE)
- Cách hoạt động 
- Bartender k đưa menu cố định -> đưa cho 1 tờ giaasy trắng và 1 cái bút
-> mình viết y/c cho 1 ly cocktail : 30% rượu rum, 50% nước cam, 2 lát chanh, k đường

-> bartender pha chế 1 ly y hệt công thức đó và đưa 1 ly duy nhất
Ưu điểm:
Chính xác: -> y/c rì được nấy, k thừa đường thiếu chanh
- tiện lợi nếu thê 1 đĩa lạc => thêm vào tờ giấy => bartender sẽ mang ra trong 1 request

3. Websocket
- bối cảnh: cần bơm đầy 1 bể bơi
- cách hoạt động: k dùng thau chậu -> nối 1 ống dẫn nước (socket connection) thẳng từ nhà máy nước vào cái bể -> nước chảy
liên tục (data stream) -> ..nhà máy bơm nước thì cái bể nhận được ngay nước tức thì
Ứng dụnng: coin, chứng, giá vàng
độ trễ thấp

playwright cơ chế của nó là wénocket -> giao tiếp trực tiếp với browser

Để 2 thằng giao tiếp với nhau thì cần cây cầu API phải có ngôn ngữ chung
FE (người VN) (CODE BẰNG TYOE SCRIPT)
BE ( mỹ tho) (code bằng JAVA/PYTHON)
thì dùng API nói chuyện vs 2 ông này cần 1 ngôn ngữ chung  - JSON (javascript object notation)

cấu trúc json rất đơn giản y sì object của typécript
100% key phải có ""
{
    "ten":"teo",
    "tuoi":25,
    "sơ_thich": ["Game", "code"]
}
{
    'ten':"teo"
}-> sai


SPA 
server side rendering
client side rendering

Thông tin 1 request mà FE gọi xuống BE

1. Method (hàh động muốn làm) => dán tem lên bìa thư để định danh hành động
- GET : LẤY thông tin (k sửa đổi gì). VD: xem ds spham
- POST: tạo mới: VD: đăng ký tk
- PUT/PATCH: sửa đổi:VD: đổi mk, cập nhật profile
- DELETE: xoá: xoá giỏ hàng

CURD: create updta read delete
2. ENDPOINT(địa chỉ) => thư thì phải có địa chỉ
BaseUrl: https://jsonplaceholder.typicode.com/
endpoint: /todos/1

3. Header( thông tin phụ) -> những thứ viết bên ngaoif phong bì

Content-Type: application/json (báo trước: trong thư viết bằng jsson)
Authrization: xác thực phân quyền (cho cơ chế JWT)

4.Body (nd thư)
Chỉ dùng cho POST/PUT/PATCH...

sử dung curl => giống như 1 gói tin nén chứa đầy đủ URL, endpoint, method, header, body.. trong 1 đoạn vb duy nhất


thông tin respone phản hồi


.
.
.
2 respone body
dữ liệu server trả về (thường là json) 

//ngày 15/1/2026

Thif
GET -> Lấy dữ liệu
POST -> tạo mới dữ liệu
PUT/PATCH
DELETE -> xoá dữ liệu







